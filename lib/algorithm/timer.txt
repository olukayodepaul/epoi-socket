defmodule MonitorGenerver do
  use GenServer
  require Logger

  alias Storage.{PgDeviceCache, GlobalSubscriberCache, DevicePresenceAggregator}

  @interval 5_000  # Check every 5 seconds, adjust as needed

  ## Public API
  def start_link(eid) do
    GenServer.start_link(__MODULE__, eid, name: via_tuple(eid))
  end

  defp via_tuple(eid), do: {:via, Registry, {:monitor_registry, eid}}

  ## GenServer Callbacks

  @impl true
  def init(eid) do
    Logger.info("Monitor init for eid=#{eid}")

    # Initialize caches
    PgDeviceCache.init(eid)
    GlobalSubscriberCache.init(eid)

    # Schedule first state tracking
    timer_ref = Process.send_after(self(), {:track_state, eid}, @interval)
    {:ok, %{eid: eid, devices: %{}, timer_ref: timer_ref}}
  end

  @impl true
  def handle_info({:track_state, eid}, state) do
    # Call your state change tracker
    case DevicePresenceAggregator.track_state_change(eid) do
      {:changed, user_status, online_devices} ->
        Logger.info("User #{eid} presence changed to #{user_status}")
        # Broadcast presence to subscribers
        GlobalSubscriberCache.broadcast_presence(eid, user_status, online_devices)

      {:unchanged, _user_status, _online_devices} ->
        # Optionally, you could refresh last_seen if needed
        :ok
    end

    # Cancel previous timer (if exists) and reschedule
    if state.timer_ref, do: Process.cancel_timer(state.timer_ref)
    timer_ref = Process.send_after(self(), {:track_state, eid}, @interval)

    {:noreply, %{state | timer_ref: timer_ref}}
  end

  @impl true
  def terminate(_reason, state) do
    if state.timer_ref, do: Process.cancel_timer(state.timer_ref)
    :ok
  end
end







defmodule Application.Monitor do
  use GenServer
  require Logger

  alias DartMessagingServer.DynamicSupervisor
  alias Util.RegistryHelper
  alias App.AllRegistry
  alias Storage.{GlobalSubscriberCache, PgDeviceCache, PgDevicesSchema}
  alias Bicp.MonitorAppPresence
  alias DevicePresenceAggregator

  @moduledoc """
  Mother process for a user. Holds state for devices, messages, etc.
  Survives socket termination and monitors device presence.
  """

  @interval 30_000        # Check every 30 seconds
  @idle_timeout 60 * 5    # Stop after 5 minutes of inactivity

  def start_link(eid) do
    GenServer.start(__MODULE__, eid, name: RegistryHelper.via_monitor_registry(eid))
  end

  @impl true
  def init(eid) do
    Logger.info("Monitor init for eid=#{eid}")
    PgDeviceCache.init(eid)
    GlobalSubscriberCache.init(eid)

    timer_ref = Process.send_after(self(), {:track_state, eid}, @interval)
    idle_ref = Process.send_after(self(), :idle_check, @idle_timeout * 1000)

    {:ok, %{eid: eid, devices: %{}, timer_ref: timer_ref, idle_ref: idle_ref, last_activity: DateTime.utc_now()}}
  end

  # Device session start
  def start_device(eid, {eid, device_id, ws_pid}) do
    GenServer.call(RegistryHelper.via_monitor_registry(eid), {:start_device, {eid, device_id, ws_pid}})
  end

  @impl true
  def handle_call({:start_device, {eid, device_id, ws_pid}}, _from, state) do
    case DynamicSupervisor.start_session({eid, device_id, ws_pid}) do
      {:ok, pid} ->
        devices = Map.put(state.devices, device_id, pid)
        {:reply, {:ok, pid}, %{state | devices: devices, last_activity: DateTime.utc_now()}}
      {:error, reason} ->
        {:reply, {:error, reason}, state}
    end
  end

  # Device registration
  @impl true
  def handle_cast({:monitor_startup_status, %{eid: eid, device_id: device_id, ws_pid: ws_pid}}, state) do

    IO.inspect("monitor_startup_status")
    now = DateTime.utc_now() |> DateTime.truncate(:second)

    case PgDeviceCache.fetch(device_id, eid, ws_pid) do
      {:ok} -> :ok
      {:error} ->
        device = %PgDevicesSchema{
          device_id: device_id,
          eid: eid,
          last_seen: now,
          ws_pid: :erlang.pid_to_list(ws_pid) |> to_string(),
          status: "ONLINE",
          last_received_version: 0,
          ip_address: nil,
          app_version: nil,
          os: nil,
          last_activity: now,
          supports_notifications: true,
          supports_media: true,
          status_source: "LOGIN",
          awareness_intention: 0,
          inserted_at: now
        }
        PgDeviceCache.save(device, eid)
    end

    AllRegistry.sent_subscriber(device_id, eid, GlobalSubscriberCache.fetch_subscriber_by_owners_eid(eid))
    {:noreply, %{state | last_activity: now}}
  end

  @impl true
  def handle_cast({:monitor_subscriber_last_seen, %{from: from, to: to, device_id: device_id, status: status}}, state) do
    GlobalSubscriberCache.put_subscribers(to, from, device_id, status)
    {:noreply, %{state | last_activity: DateTime.utc_now()}}
  end

  @impl true
  def handle_cast({:monitor_pong_counter, {eid, device_id, status}}, state) do
    PgDeviceCache.update_status(eid, device_id, "PONG", status)
    {:noreply, %{state | last_activity: DateTime.utc_now()}}
  end

  @impl true
  def handle_cast({:monitor_terminate_child, {eid, device_id}}, state) do
    PgDeviceCache.update_status(eid, device_id, "LOGOUT", "OFFLINE")
    {:noreply, %{state | last_activity: DateTime.utc_now()}}
  end

  # Scheduled state tracking
  @impl true
  def handle_info({:track_state, owner_eid}, state) do
    case DevicePresenceAggregator.track_state_change(owner_eid) do
      {:changed, user_status, online_devices} -> :ok
        # MonitorAppPresence.broadcast_state(owner_eid, user_status, online_devices)
      {:unchanged, _user_status, _online_devices} -> :ok
    end

    new_timer_ref = Process.send_after(self(), {:track_state, owner_eid}, @interval)
    {:noreply, %{state | timer_ref: new_timer_ref}}
  end

  # Check for idle timeout
  @impl true
  def handle_info(:idle_check, state) do
    elapsed = DateTime.diff(DateTime.utc_now(), state.last_activity)
    if elapsed >= @idle_timeout do
      Logger.info("Idle timeout reached for #{state.eid}, terminating Mother process")
      {:stop, :normal, state}
    else
      idle_ref = Process.send_after(self(), :idle_check, @idle_timeout * 1000)
      {:noreply, %{state | idle_ref: idle_ref}}
    end
  end

  # Catch-all for unexpected messages
  @impl true
  def handle_info(msg, state) do
    Logger.debug("Unhandled message in Mother: #{inspect(msg)}")
    {:noreply, state}
  end
end


